#!/usr/bin/bash

# if this usb device is connected to the host the vm will be terminated
killSwitchVendorID="XXXX"
killSwitchProductId="XXXX"

# virsh applies localization to returned values, this array should contain equivalents to 'shutoff' in different languages
# en-us, pt-br
shutoffWords=("shutoff" "desligado")

# assumes the vm is not available
isVMAvailable=0

# assumes the vm is not running
isVMRunning=0

# stops if not running as root
if [ ! $(whoami) == "root" ]; then
    echo "This script should be run as root, as it needs to start and stop system services."
    exit 1
fi

# stops if the vm name was not specified
if [ "$1" == "" ]; then
    echo "No virtual machine name specified."
    exit 1
fi

# gets the availability of the vm
for word in ${shutoffWords[@]}; do
    if [[ $word == $(virsh domstate "$1") ]]; then
        isVMAvailable=1
        break
    fi
done

# prevents starting a running or inexistent vm
if [[ $isVMAvailable != 1 ]]; then
    echo "The specified virtual machine is not available"
    exit 1
fi

# sends confirmation message
echo "Finishing the display manager in 10 seconds, you can exit the terminal if you want"
sleep 10

# logout user
pkill -TERM -u "$2"
sleep 5

# stops the display manager
systemctl stop display-manager
sleep 5

# if using plasma, kwin may crash when sddm is stopped
# sudo pkill -KILL kwin_x11

# drops caches
echo 3 > /proc/sys/vm/drop_caches

# compacts memory
echo 1 > /proc/sys/vm/compact_memory

# if using hugepages, this will allocate 4096 pages of 2MiB each = 8GiB
# sysctl vm.nr_hugepages=4096

# reduce VM jitter? https://rokups.github.io/#!pages/gaming-vm-performance.md
sysctl vm.stat_interval=300

# if reserving cores to the host, this will lock writeback tasks to use only host-specific cores - 88 is the hexadecimal for the bitmask 10001000
# echo 88 > /sys/bus/workqueue/devices/writeback/cpumask

# changes the cpu frequency governor to performance
for i in /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_governor; do
    echo "performance" > $i
done

# starts the specified vm
virsh start "$1"
isVMRunning=1

# waits some time before starting to check if the VM has stopped
sleep 10
# changes the qemu process scheduler to FIFO and nice to -20
ls /proc/$(pgrep -f "$1")/task | xargs -n 1 chrt -f -p 99
ls /proc/$(pgrep -f "$1")/task | xargs renice -n -20
# checks if the VM has stopped at every 5 seconds
while [[ $isVMRunning == 1 ]]; do
    # gets the vm running state
    for word in ${shutoffWords[@]}; do
        if [[ $word == $(virsh domstate "$1") ]]; then
            isVMRunning=0
            break
        fi
    done
    
    # checks the presence of the specified usb killswitch
    if [[ $(awk '$2 == "Vendor='$killSwitchVendorID'" && $3 == "ProdID='$killSwitchProductId'" { print $0 }' /sys/kernel/debug/usb/devices) != "" ]]; then 
        virsh destroy "$1"
        # don't interfere with isVMRunning here, wait for libvirt to kill the VM
    fi
    
    # waits some time before trying again
    sleep 5
done

# waits 5 seconds for the gpu to be returned to the host
sleep 5

# changes the cpu frequency governor back to powersave
for i in /sys/devices/system/cpu/cpu[0-9]*/cpufreq/scaling_governor; do
    echo "powersave" > $i
done

# if reserving cores to the host, you can unlock writeback to use all cores again
# echo ff > /sys/bus/workqueue/devices/writeback/cpumask

# restore reduce jitter workaround
sysctl vm.stat_interval=1

# if using hugepages, this will free them
# sysctl vm.nr_hugepages=0

# starts the display manager again
systemctl start display-manager
